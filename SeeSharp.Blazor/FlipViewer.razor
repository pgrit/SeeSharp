@using Microsoft.JSInterop
@using System.Text.Json.Serialization
@inject IJSRuntime JSRuntime

@namespace SeeSharp.Blazor

@if (flipCode != null)
    @((MarkupString)flipCode)

@code {
    string flipCode;
    string flipJson;

    [Parameter]
    public SimpleImageIO.FlipBook Flip { get; set; }
    SimpleImageIO.FlipBook lastFlip;

    public record struct OnClickEventArgs
    (
        int X,
        int Y,

        string key,
        bool isPressed,

        int mouseButton,
        bool isButton,

        int deltaY,
        int selectedIndex,
        string registryKey
    )
    {
    }

    [Parameter]
    public EventCallback<OnClickEventArgs> OnClick { get; set; }
    [Parameter]
    public EventCallback<OnClickEventArgs> OnWheel { get; set; } 
    [Parameter]
    public EventCallback<OnClickEventArgs> OnMouseOver { get; set; } 
    [Parameter]
    public EventCallback<OnClickEventArgs> OnKey { get; set; } 

    protected override async Task OnParametersSetAsync()
    {
        if (Flip == null)
        {
            flipCode = null;
            lastFlip = null;
            return;
        }

        if (lastFlip == Flip) return;

        await Task.Run(() => {
            if (Flip.Count == 0) {
                flipJson = null;
                flipCode = "<p>empty flip book</p>";
                return;
            }
            var code = Flip.Generate();
            flipCode = code.Html;
            flipJson = code.Data;
        });

        lastFlip = Flip;
    }

    public struct _OnFlipClickArgs
    {
        [JsonInclude] public string key;
        [JsonInclude] public bool isPressed;
        [JsonInclude] public int mouseButtom;
        [JsonInclude] public bool isButtom;
        [JsonInclude] public int deltaY;
        [JsonInclude] public int selectedIndex;
        [JsonInclude] public string registryKey;
    }

    [JSInvokable]
    public void _OnFlipClick(int buttom)
    {
        OnClick.InvokeAsync(new(X: -1, Y: -1, key: "", isPressed: false, mouseButton: buttom, isButton: false, deltaY: 0, selectedIndex: -1, registryKey: "")).Wait();
    }

    // IMPORTANT: There is a bool for altKey, but on the React side a wheel event only is fired when alt is pressed, so altKey is more or less redundant
    [JSInvokable]
    public void _OnFlipWheel(int deltaY)
    {
        OnWheel.InvokeAsync(new(X: -1, Y: -1, key: "", isPressed: false, mouseButton: -1, isButton: false, deltaY: deltaY, selectedIndex: -1, registryKey: "")).Wait();
    }

    [JSInvokable]
    public void _OnFlipMouseOver(int x, int y)
    {
        OnMouseOver.InvokeAsync(new(X: x, Y: y, key: "", isPressed: false, mouseButton: -1, isButton: false, deltaY: 0, selectedIndex: -1, registryKey: "")).Wait();
    }

    [JSInvokable]
    public void _OnFlipKey(int selectedIdx, string keyStr, string keyPressed, bool isPressed)
    {
        OnKey.InvokeAsync(new(X: -1, Y: -1, key: keyPressed, isPressed: isPressed, mouseButton: -1, isButton: false, deltaY: 0, selectedIndex: selectedIdx, registryKey: keyStr)).Wait();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        // Need to wait with invoking the JS code until the HTML got added to the DOM on the client side
        if (flipJson != null)
        {
            await JSRuntime.InvokeVoidAsync(
                "makeFlipBook", 
                flipJson, 
                DotNetObjectReference.Create(this), 
                nameof(_OnFlipClick), 
                DotNetObjectReference.Create(this), 
                nameof(_OnFlipWheel),
                DotNetObjectReference.Create(this), 
                nameof(_OnFlipMouseOver),
                DotNetObjectReference.Create(this), 
                nameof(_OnFlipKey)
                );
            flipJson = null;
        }
    }
}