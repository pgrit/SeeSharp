namespace SeeSharp.Integrators.Bidir;

using Walk = RandomWalk<LightPathCache.LightPathPayload>;

public abstract partial class BidirBase<CameraPayloadType> {
    /// <summary>
    /// Called for each sample generated by the light tracer.
    /// </summary>
    /// <param name="weight">The sample contribution not yet weighted by MIS</param>
    /// <param name="misWeight">The MIS weight that will be multiplied on the sample weight</param>
    /// <param name="pixel">The pixel to which this sample contributes</param>
    /// <param name="lightVertex">The last vertex on the light path</param>
    /// <param name="pathPdfs">Surface area pdfs of all sampling techniques. </param>
    /// <param name="distToCam">Distance of the last vertex to the camera</param>
    protected virtual void OnLightTracerSample(RgbColor weight, float misWeight, Pixel pixel,
                                               PathVertex lightVertex, in BidirPathPdfs pathPdfs, float distToCam) { }

    /// <summary>
    /// Computes the MIS weight of a light tracer sample, for example via the balance heuristic.
    /// </summary>
    /// <param name="lightVertex">The last vertex of the light sub-path</param>
    /// <param name="pathPdfs">Surface area pdfs of all sampling techniques. </param>
    /// <param name="pixel">The pixel on the image the path contributes to</param>
    /// <param name="distToCam">Distance between the camera and the last light path vertex</param>
    /// <returns>MIS weight of the sampled path</returns>
    public abstract float LightTracerMis(PathVertex lightVertex, in BidirPathPdfs pathPdfs, Pixel pixel, float distToCam);

    /// <summary>
    /// Connects all vertices along all light paths to the camera via shadow rays ("light tracing").
    /// </summary>
    protected void SplatLightVertices() {
        ForEachVertex(ConnectLightVertexToCamera);
    }

    void ConnectLightVertexToCamera(in PathVertex vertex, in PathVertex ancestor, Vector3 dirToAncestor) {
        if (vertex.Depth + 1 < MinDepth) return;

        // Compute image plane location
        RNG rng = new(); // TODO / FIXME this is not used atm, so we can pass a dummy. But must update once fancier cameras are implemented!
        var response = Scene.Camera.SampleResponse(vertex.Point, ref rng);
        if (!response.IsValid)
            return;

        if (Scene.Raytracer.IsOccluded(vertex.Point, response.Position))
            return;

        var dirToCam = response.Position - vertex.Point.Position;
        float distToCam = dirToCam.Length();
        dirToCam /= distToCam;

        SurfaceShader shader = new(vertex.Point, dirToCam, false);

        var bsdfValue = shader.Evaluate(dirToAncestor);
        if (bsdfValue == RgbColor.Black)
            return;

        // The shading cosine only cancels out with the Jacobian if the geometry aligns with the shading geometry
        bsdfValue *=
            float.Abs(Vector3.Dot(vertex.Point.ShadingNormal, dirToAncestor)) /
            float.Abs(Vector3.Dot(vertex.Point.Normal, dirToAncestor));

        // Compute the surface area pdf of sampling the previous vertex instead
        var (pdfReverse, _) = shader.Pdf(dirToAncestor);
        if (ancestor.Point.Mesh != null)
            pdfReverse *= SampleWarp.SurfaceAreaToSolidAngle(vertex.Point, ancestor.Point);

        // Gather the PDFs for MIS computation
        int numPdfs = vertex.Depth + 1;
        int lastCameraVertexIdx = -1;
        Span<float> camToLight = stackalloc float[numPdfs];
        Span<float> lightToCam = stackalloc float[numPdfs];
        var pathPdfs = new BidirPathPdfs(lightToCam, camToLight);
        pathPdfs.GatherLightPdfs(PathCache, vertex, lastCameraVertexIdx);
        pathPdfs.PdfsCameraToLight[0] = response.PdfEmit;
        pathPdfs.PdfsCameraToLight[1] = pdfReverse;
        if (vertex.Depth == 1)
            pathPdfs.PdfNextEvent = NextEventPdf(vertex.Point, ancestor.Point);

        float misWeight = LightTracerMis(vertex, pathPdfs, response.Pixel, distToCam);

        // Compute image contribution and splat
        RgbColor weight = vertex.Weight * bsdfValue * response.Weight / NumLightPaths;
        Scene.FrameBuffer.Splat(response.Pixel, misWeight * weight);

        // Log the sample
        RegisterSample(weight, misWeight, response.Pixel, 0, vertex.Depth, vertex.Depth + 1);
        OnLightTracerSample(weight, misWeight, response.Pixel, vertex, pathPdfs, distToCam);
    }

    /// <summary>
    /// Called once per iteration after the light paths have been traced.
    /// Use this to create acceleration structures etc.
    /// </summary>
    protected abstract void ProcessPathCache();

    /// <summary>
    /// The generated light paths in the current iteration
    /// </summary>
    protected PathCache PathCache { get; set; }

    /// <summary>
    /// Randomly samples either the background or an emitter from the scene
    /// </summary>
    /// <returns>The emitter and its selection probability</returns>
    public virtual (Emitter, float) SelectLight(ref RNG rng) {
        if (BackgroundProbability > 0 && rng.NextFloat() <= BackgroundProbability) {
            return (null, BackgroundProbability);
        } else {
            var emitter = Scene.Emitters[rng.NextInt(Scene.Emitters.Count)];
            return (emitter, (1 - BackgroundProbability) / Scene.Emitters.Count);
        }
    }

    /// <summary>
    /// Computes the sampling probability used by <see cref="SelectLight"/>
    /// </summary>
    /// <param name="em">An emitter in the scene</param>
    /// <returns>The selection probability</returns>
    public virtual float SelectLightPmf(Emitter em) {
        if (em == null) { // background
            return BackgroundProbability;
        } else {
            return (1 - BackgroundProbability) / Scene.Emitters.Count;
        }
    }

    /// <summary>
    /// Probability of selecting the background instead of a surface emitter
    /// </summary>
    public virtual float BackgroundProbability
    => Scene.Background != null ? 1 / (1.0f + Scene.Emitters.Count) : 0;

    /// <summary>
    /// Samples a ray from an emitter in the scene
    /// </summary>
    /// <param name="rng">Random number generator</param>
    /// <param name="emitter">The emitter to sample from</param>
    /// <returns>Sampled ray, weights, and probabilities</returns>
    public virtual EmitterSample SampleEmitter(ref RNG rng, Emitter emitter) {
        var primaryPos = rng.NextFloat2D();
        var primaryDir = rng.NextFloat2D();
        return emitter.SampleRay(primaryPos, primaryDir);
    }

    /// <summary>
    /// Computes the importance sampling pdf to generate an edge from a point on an emitter to a point
    /// in the scene. Result is the product of two surface area densities and a discrete selection
    /// probability.
    /// </summary>
    /// <param name="emitter">An emitter in the scene</param>
    /// <param name="point">Point on the emitter's surface</param>
    /// <param name="lightToSurface">Direction from the emitter to the illuminated surface</param>
    /// <param name="reversePdfJacobian">
    /// Geometry term to convert the solid angle density on the emitter's surface to a surface area
    /// density at the illuminated point.
    /// </param>
    /// <returns>The full, product surface area density of sampling this ray from the emitter</returns>
    public virtual float ComputeEmitterPdf(Emitter emitter, SurfacePoint point, Vector3 lightToSurface,
                                           float reversePdfJacobian) {
        float pdfEmit = emitter.PdfRay(point, lightToSurface);
        pdfEmit *= reversePdfJacobian;
        pdfEmit *= SelectLightPmf(emitter);
        return pdfEmit;
    }

    /// <summary>
    /// Computes the pdf of sampling a ray from the background that illuminates a point.
    /// </summary>
    /// <param name="from">The illuminated point</param>
    /// <param name="lightToSurface">Direction from the background to the illuminated point</param>
    /// <returns>Sampling density (solid angle times discrete)</returns>
    public virtual float ComputeBackgroundPdf(Vector3 from, Vector3 lightToSurface) {
        float pdfEmit = Scene.Background.RayPdf(from, lightToSurface);
        pdfEmit *= SelectLightPmf(null);
        return pdfEmit;
    }

    /// <summary>
    /// Samples a ray from the background into the scene.
    /// </summary>
    /// <param name="rng">Random number generator</param>
    /// <returns>The sampled ray, its weight, and the sampling pdf</returns>
    public virtual (Ray, RgbColor, float) SampleBackground(ref RNG rng) {
        // Sample a ray from the background towards the scene
        var primaryPos = rng.NextFloat2D();
        var primaryDir = rng.NextFloat2D();
        return Scene.Background.SampleRay(primaryPos, primaryDir);
    }

    /// <summary>
    /// Resets the path cache and populates it with a new set of light paths.
    /// </summary>
    /// <param name="seed">Base seed for the random number generator, hashed with the iteration to obtain the actual seed.</param>
    /// <param name="iter">Index of the current iteration, used to seed the random number generator.</param>
    public virtual void TraceLightPaths(uint seed, uint iter) {
        // If the number of light paths changes, we simply create a new path cache (should not happen often)
        if (PathCache == null || NumLightPaths != PathCache.NumPaths)
            PathCache = new PathCache(NumLightPaths, Math.Min(MaxDepth + 1, 10));
        else
            PathCache.Clear();

        LightPathWalk walkModifier = new(PathCache, (to, from, _) => NextEventPdf(from, to));

        Parallel.For(0, NumLightPaths, idx => {
            var rng = new RNG(seed, (uint)idx, iter);
            TraceLightPath(ref rng, idx, walkModifier);
        });

        PathCache.Prepare();
    }

    /// <summary>
    /// Called for each light path, used to populate the path cache.
    /// </summary>
    /// <returns>
    /// The index of the last vertex along the path.
    /// </returns>
    public virtual void TraceLightPath(ref RNG rng, int idx, LightPathWalk walkModifier) {
        // Select an emitter or the background
        var (emitter, prob) = SelectLight(ref rng);
        if (emitter != null)
            TraceEmitterPath(ref rng, emitter, prob, idx, walkModifier);
        else
            TraceBackgroundPath(ref rng, prob, idx, walkModifier);
    }

    /// <summary>
    /// Callback that is invoked for each vertex along a path
    /// </summary>
    /// <param name="vertex">Reference to the vertex</param>
    /// <param name="ancestor">Reference to the vertex's ancestor</param>
    /// <param name="dirToAncestor">Normalized direction from the vertex to the ancestor</param>
    public delegate void ProcessVertex(in PathVertex vertex, in PathVertex ancestor, Vector3 dirToAncestor);

    /// <summary>
    /// Utility function that iterates over all vertices of all light paths, excluding the point on the light itself.
    /// </summary>
    /// <param name="func">Delegate invoked on each vertex</param>
    public void ForEachVertex(ProcessVertex func) {
        Parallel.For(0, PathCache?.NumPaths ?? 0, pathIdx => {
            for (int i = 1; i < PathCache.Length(pathIdx); ++i) {
                var vertex = PathCache.GetPathVertex(pathIdx, i);
                var ancestor = PathCache.GetPathVertex(pathIdx, i - 1);
                var dirToAncestor = Vector3.Normalize(ancestor.Point.Position - vertex.Point.Position);
                func(vertex, ancestor, dirToAncestor);
            }
        });
    }

    public ref PathVertex this[int vertexIdx] => ref PathCache.GetVertex(vertexIdx);

    public ref PathVertex this[int pathIdx, int vertexIdx] => ref PathCache.GetPathVertex(pathIdx, vertexIdx);

    /// <returns>The length of the pathIdx'th path</returns>
    public int Length(int pathIdx) => PathCache.Length(pathIdx);

    /// <returns>The global vertex index of the vertexIdx'th vertex along the pathIdx'th path</returns>
    public int GetGlobalVertexIdx(int pathIdx, int vertexIdx) => PathCache.GetPathVertexIndex(pathIdx, vertexIdx);

    /// <summary>
    /// The total number of light vertices in the cache
    /// </summary>
    public int NumVertices => PathCache.NumVertices;

    protected virtual void TraceEmitterPath(ref RNG rng, Emitter emitter, float selectProb, int idx, LightPathWalk walkModifier) {
        var emitterSample = SampleEmitter(ref rng, emitter);

        // Account for the light selection probability in the MIS weights
        emitterSample.Pdf *= selectProb;

        if (emitterSample.Pdf == 0 || emitterSample.Weight == RgbColor.Black) { // Avoid NaNs and terminate early
            PathCache.Commit(idx, []);
            return;
        }

        var walk = new Walk(Scene, ref rng, MaxDepth, walkModifier);
        walk.StartFromEmitter(emitterSample, emitterSample.Weight / selectProb, new() { PathIdx = idx });
    }

    protected virtual void TraceBackgroundPath(ref RNG rng, float selectProb, int idx, LightPathWalk walkModifier) {
        var (ray, weight, pdf) = SampleBackground(ref rng);

        // Account for the light selection probability
        pdf *= selectProb;
        weight /= selectProb;

        if (pdf == 0 || weight == RgbColor.Black) { // Avoid NaNs and terminate early
            PathCache.Commit(idx, []);
            return;
        }

        Debug.Assert(float.IsFinite(weight.Average));

        var walk = new Walk(Scene, ref rng, MaxDepth, walkModifier);
        walk.StartFromBackground(ray, weight, pdf, new() { PathIdx = idx });
    }

    public struct LightPathPayload {
        /// <summary>
        /// Index of the last vertex along the path that was generated
        /// </summary>
        public int LastId;

        /// <summary>
        /// Index of the generated path in the cache
        /// </summary>
        public int PathIdx;

        public float nextReversePdf;

        public float maxRoughness;

        public SurfacePoint FirstPoint, SecondPoint;

        public bool FromBackground;
    }

    /// <summary>
    /// Performs a random walk and stores all vertices along the path in a <see cref="PathCache" />.
    /// </summary>
    public class LightPathWalk : Walk.RandomWalkModifier {
        /// <summary>
        /// The cache storing the generated path
        /// </summary>
        public readonly PathCache Cache;

        ThreadLocal<PathBuffer<PathVertex>> threadBuffers = new(() => new(16));

        /// <summary>
        /// Computes the next event sampling pdf
        /// </summary>
        /// <param name="origin">Initial vertex on the light source or background</param>
        /// <param name="primary">First vertex intersected in the scene</param>
        /// <param name="nextDirection">Direction towards the next vertex</param>
        /// <returns>Next event pdf to sample the same edge</returns>
        public delegate float NextEventPdfCallback(SurfacePoint origin, SurfacePoint primary, Vector3 nextDirection);

        public NextEventPdfCallback ComputeNextEventPdf;

        /// <summary>
        /// Prepares an object that can be used to perform one random walk.
        /// </summary>
        /// <param name="cache">The cache to store the path in</param>
        /// <param name="nextEventPdf">Callback that computes the next event sampling PDF once the first two vertices are known</param>
        public LightPathWalk(PathCache cache, NextEventPdfCallback nextEventPdf) {
            Cache = cache;
            ComputeNextEventPdf = nextEventPdf;
        }

        public override void OnStartEmitter(ref Walk walk, EmitterSample emitterSample, RgbColor initialWeight) {
            walk.Payload.nextReversePdf = 0.0f;
            walk.Payload.maxRoughness = 0.0f;

            threadBuffers.Value.Add(new PathVertex {
                Point = emitterSample.Point,
                PathId = walk.Payload.PathIdx,
                FromBackground = false,
                Depth = 0,
            });
            walk.Payload.FirstPoint = emitterSample.Point;
            walk.Payload.FromBackground = false;
        }

        public override void OnStartBackground(ref Walk walk, Ray ray, RgbColor initialWeight, float pdf) {
            walk.Payload.nextReversePdf = 0.0f;
            walk.Payload.FirstPoint = new SurfacePoint { Position = ray.Origin };

            threadBuffers.Value.Add(new PathVertex {
                Point = walk.Payload.FirstPoint,
                PathId = walk.Payload.PathIdx,
                FromBackground = true,
                Depth = 0,
            });
            walk.Payload.FromBackground = true;
        }

        public override RgbColor OnHit(ref Walk walk, in SurfaceShader shader, float pdfFromAncestor,
                                    RgbColor throughput, int depth, float toAncestorJacobian) {
            float roughness = shader.GetRoughness();
            if (depth == 1) walk.Payload.SecondPoint = shader.Point;

            // The next event pdf is computed once the path has three vertices
            float pdfNextEventAncestor = 0.0f;
            if (depth == 2 && ComputeNextEventPdf != null)
                pdfNextEventAncestor = ComputeNextEventPdf(walk.Payload.FirstPoint, walk.Payload.SecondPoint, -shader.Context.OutDirWorld);

            threadBuffers.Value.Add(new PathVertex {
                Point = shader.Point,
                PdfFromAncestor = pdfFromAncestor,
                PdfReverseAncestor = walk.Payload.nextReversePdf,
                PathId = walk.Payload.PathIdx,
                Weight = throughput,
                Depth = (byte)depth,
                PdfNextEventAncestor = pdfNextEventAncestor,
                MaximumRoughness = MathF.Max(roughness, walk.Payload.maxRoughness),
                FromBackground = walk.Payload.FromBackground,
            });
            return RgbColor.Black;
        }

        public override void OnContinue(ref Walk walk, float pdfToAncestor, int depth) {
            walk.Payload.nextReversePdf = pdfToAncestor;
        }

        public override void OnTerminate(ref Walk walk) {
            Cache.Commit(walk.Payload.PathIdx, threadBuffers.Value.AsSpan());
            threadBuffers.Value.Clear();
        }
    }
}